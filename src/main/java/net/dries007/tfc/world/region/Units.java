/*
 * Licensed under the EUPL, Version 1.2.
 * You may obtain a copy of the Licence at:
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 */

package net.dries007.tfc.world.region;

/**
 * A class for transforming between different coordinate systems used by the region generator system.
 * <ul>
 *     <li><strong>Blocks</strong> are obvious.</li>
 *     <li><strong>Quart</strong> coordinates are the scale at which biomes generate (1 Quart = 4 Blocks)</li>
 *     <li><strong>Chunks</strong> coordinates represent single Minecraft chunks (1 Chunk = 4 Quart = 16 Blocks)</li>
 *     <li><strong>Grid</strong> coordinates are the smallest unit generated by the region system. They are zoomed by a power of 2 via the layer system, up to the scale of <strong>Quart</strong> coordinates. (1 Grid = 32 Quart = 128 Blocks)</li>
 *     <li><strong>Partition</strong> coordinates are a slightly larger scale than grid coordinates, which are used for collecting and referencing rivers. (1 Part = 3 Grid = 384 Blocks)</li>
 *     <li><strong>Cell</strong> coordinates are the coordinates used for an entire region. (1 Cell = 96 Grid = 12,288 Blocks)</li>
 * </ul>
 * Despite the fact <strong>Grid</strong>, <strong>Partition</strong>, and <strong>Cell</strong> coordinates appear to be strict multiples of each other, and thus easy to convert between, when referring to the ownership of a single point, the coordinates may not align intuitively.
 * This comes from the fact {@link Region}s are not square - so the region that contains a particular grid coordinate, by ownership (generates the {@link Region.Point} associated with it) may not be the same as converting the grid coordinate directly to it's containing cell coordinate.
 * <p>
 * When querying by grid coordinates then, the first thing that must be done is query a {@link RegionGenerator} to obtain the cell which the grid coordinate lies - <em>then</em> it is possible to use that cell's coordinates as keys into a cell-based cache, for example.
 * <p>
 * Note that a {@link Region} is larger than a 96 x 96 square, due to needing to account for edge cases caused by the cell shapes. They thus have some level of overlap, although an individual grid position will only belong to a single cell, and thus {@link Region}.
 *
 * @see net.minecraft.core.QuartPos
 */
public final class Units
{
    public static final int PARTITION_BITS = 5;
    public static final int PARTITION_BIT_MASK = (1 << PARTITION_BITS) - 1;
    public static final int PARTITION_WIDTH_IN_GRID = 3;

    public static final int CELL_WIDTH_IN_PARTITION = (1 << PARTITION_BITS);
    public static final int CELL_WIDTH_IN_GRID = CELL_WIDTH_IN_PARTITION * PARTITION_WIDTH_IN_GRID;

    public static final int REGION_RADIUS_IN_GRID = CELL_WIDTH_IN_GRID + 5;
    public static final int REGION_WIDTH_IN_GRID = 1 + 2 * REGION_RADIUS_IN_GRID;

    public static final int QUART_BITS = 2;
    public static final int GRID_BITS = 7;

    public static final int GRID_WIDTH_IN_BLOCK = (1 << GRID_BITS);
    public static final int GRID_WIDTH_IN_QUART = (1 << (GRID_BITS - QUART_BITS));

    public static int cellToPart(int cell)
    {
        return cell << PARTITION_BITS;
    }

    public static int partToCell(int part)
    {
        return part >> PARTITION_BITS;
    }

    public static int gridToCell(int grid)
    {
        return Math.floorDiv(grid, CELL_WIDTH_IN_GRID);
    }

    public static int cellToGrid(int cell)
    {
        return cell * CELL_WIDTH_IN_GRID;
    }

    public static int gridToPart(int grid)
    {
        return Math.floorDiv(grid, PARTITION_WIDTH_IN_GRID);
    }

    public static int partToGrid(int part)
    {
        return part * PARTITION_WIDTH_IN_GRID;
    }

    public static int quartToGrid(int quart)
    {
        return quart >> (GRID_BITS - QUART_BITS);
    }

    public static double quartToGridExact(double quart)
    {
        return quart / GRID_WIDTH_IN_QUART;
    }

    public static int gridToQuart(int grid)
    {
        return grid << (GRID_BITS - QUART_BITS);
    }

    public static double blockToGridExact(double block)
    {
        return block / GRID_WIDTH_IN_BLOCK;
    }

    public static int blockToGrid(int block)
    {
        return block >> GRID_BITS;
    }

    public static int index(int x, int z)
    {
        return (x & 15) | ((z & 15) << 4);
    }
}
